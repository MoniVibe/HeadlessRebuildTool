name: "Buildbox: on-demand rebuild + headless sim"

on:
  workflow_dispatch:
    inputs:
      title:
        description: "Which project"
        type: choice
        options: [space4x, godgame]
        required: true
      ref:
        description: "Git ref/branch/SHA to test (must be pushed to GitHub)"
        required: true
        default: "main"
      repeat:
        description: "Repeat runs"
        required: true
        default: "1"
      wait_for_result:
        description: "Wait for result zips"
        type: boolean
        required: true
        default: true
      result_wait_timeout_sec:
        description: "Max seconds to wait for result zip when wait_for_result=true"
        required: false
        default: "600"
      clean_cache:
        description: "Clear Bee/lock caches in the worktree before build"
        type: boolean
        required: true
        default: false
      pure_green:
        description: "Enable strict pure-green build/runtime error scan"
        type: boolean
        required: true
        default: false
      pure_green_playmode:
        description: "Run PlayMode test gate (editor-runtime parity check)"
        type: boolean
        required: true
        default: false
      queue_root:
        description: "Optional override queue root (blank = default C:\\polish\\anviloop\\<title>\\queue)"
        required: false
        default: ""
      puredots_ref:
        description: "Optional PureDOTS ref/branch/SHA (blank = origin/main)"
        required: false
        default: ""
      scenario_rel:
        description: "Optional scenario rel path (Assets/... or Packages/...)"
        required: false
        default: ""
      env_json:
        description: "Optional env JSON map (e.g. {\"PUREDOTS_BUGHUNT\":\"1\"})"
        required: false
        default: ""
      tools_ref:
        description: "Optional HeadlessRebuildTool ref/sha for tools repo (blank = use workflow sha)"
        required: false
        default: ""

permissions:
  contents: read

jobs:
  run:
    runs-on: [self-hosted, buildbox]
    timeout-minutes: 240

    steps:
      - name: Preflight guard (runner paths/flags)
        shell: pwsh
        run: |
          $guard = Join-Path $env:TRI_ROOT "Tools\HeadlessRebuildTool\Polish\Ops\preflight_guard.ps1"
          if (-not (Test-Path $guard)) {
            $guard = Join-Path $env:TRI_ROOT "Tools\Polish\Ops\preflight_guard.ps1"
          }
          if (-not (Test-Path $guard)) { throw "preflight_guard.ps1 not found on buildbox tools repo" }
          & $guard

      - name: Run pipeline on desktop (local Tri install)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $title = '${{ inputs.title }}'
          $ref   = '${{ inputs.ref }}'
          $repeat = [int]'${{ inputs.repeat }}'
          $wait   = '${{ inputs.wait_for_result }}' -eq 'true'
          $resultWaitTimeoutSec = 600
          $resultWaitTimeoutRaw = '${{ inputs.result_wait_timeout_sec }}'
          if (-not [string]::IsNullOrWhiteSpace($resultWaitTimeoutRaw)) {
            $parsedResultWaitTimeout = 0
            if ([int]::TryParse($resultWaitTimeoutRaw, [ref]$parsedResultWaitTimeout) -and $parsedResultWaitTimeout -gt 0) {
              $resultWaitTimeoutSec = $parsedResultWaitTimeout
            }
          }
          $clean  = '${{ inputs.clean_cache }}' -eq 'true'
          $pureGreen = '${{ inputs.pure_green }}' -eq 'true'
          $pureGreenPlayMode = '${{ inputs.pure_green_playmode }}' -eq 'true'
          $scenarioRel = '${{ inputs.scenario_rel }}'
          $envJson = '${{ inputs.env_json }}'
          $toolsRef = '${{ inputs.tools_ref }}'
          $scenarioId = ""
          if (-not [string]::IsNullOrWhiteSpace($scenarioRel)) {
            try {
              $scenarioId = [IO.Path]::GetFileNameWithoutExtension($scenarioRel)
            } catch {
              $scenarioId = ""
            }
          }

          if ([string]::IsNullOrWhiteSpace($env:TRI_ROOT)) { throw "Missing TRI_ROOT env var on desktop." }
          if ([string]::IsNullOrWhiteSpace($env:UNITY_EXE)) { throw "Missing UNITY_EXE env var on desktop." }
          if (-not (Test-Path $env:UNITY_EXE)) { throw "UNITY_EXE not found: $env:UNITY_EXE" }

          $tri = $env:TRI_ROOT
          $projectRepoUrl = if ($title -eq 'godgame') { 'https://github.com/MoniVibe/Godgame.git' } else { 'https://github.com/MoniVibe/Space4x.git' }
          $toolsRepoUrl = 'https://github.com/MoniVibe/HeadlessRebuildTool.git'
          $puredotsRepoUrl = 'https://github.com/MoniVibe/PureDOTS.git'

          function Ensure-OriginHttps {
            param([string]$RepoPath, [string]$HttpsUrl)
            if (-not (Test-Path (Join-Path $RepoPath ".git"))) { return }
            & git -c "safe.directory=$RepoPath" -C $RepoPath remote get-url origin *> $null
            if ($LASTEXITCODE -eq 0) {
              & git -c "safe.directory=$RepoPath" -C $RepoPath remote set-url origin $HttpsUrl
            } else {
              & git -c "safe.directory=$RepoPath" -C $RepoPath remote add origin $HttpsUrl
            }
          }

          # Local repos expected at: TRI_ROOT\space4x and TRI_ROOT\godgame
          $repoPath = Join-Path $tri $title
          if (-not (Test-Path $repoPath)) { throw "Repo missing: $repoPath" }
          Ensure-OriginHttps -RepoPath $repoPath -HttpsUrl $projectRepoUrl

          # Local tools expected at: TRI_ROOT\Tools\HeadlessRebuildTool\Polish\pipeline_smoke.ps1
          $pipeline = Join-Path $tri "Tools\\HeadlessRebuildTool\\Polish\\pipeline_smoke.ps1"
          if (-not (Test-Path $pipeline)) {
            $pipeline = Join-Path $tri "Tools\\Polish\\pipeline_smoke.ps1"
          }
          if (-not (Test-Path $pipeline)) { throw "pipeline_smoke.ps1 not found: $pipeline" }

          # Ensure tools repo is up-to-date on buildbox so diagnostics scripts are current.
          $toolsRepo = Split-Path -Parent (Split-Path -Parent $pipeline)
          if (Test-Path $toolsRepo) {
            try {
              Ensure-OriginHttps -RepoPath $toolsRepo -HttpsUrl $toolsRepoUrl
              git -c "safe.directory=$toolsRepo" -C $toolsRepo fetch origin --prune | Out-Null
              git -c "safe.directory=$toolsRepo" -C $toolsRepo checkout main | Out-Null
              git -c "safe.directory=$toolsRepo" -C $toolsRepo pull --ff-only origin main | Out-Null
            } catch {
              Write-Warning "Failed to update tools repo: $($_.Exception.Message)"
            }
          }

          $toolsRepo = Split-Path -Parent $pipeline
          $toolsRepo = Split-Path -Parent $toolsRepo
          if ([string]::IsNullOrWhiteSpace($toolsRef)) {
            $toolsRef = '${{ github.sha }}'
          }
          $toolsCheckout = $toolsRef
          if (Test-Path (Join-Path $toolsRepo ".git")) {
            Ensure-OriginHttps -RepoPath $toolsRepo -HttpsUrl $toolsRepoUrl
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo fetch origin --prune
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo show-ref --verify --quiet ("refs/remotes/origin/" + $toolsRef)
            if ($LASTEXITCODE -eq 0) { $toolsCheckout = "origin/$toolsRef" }
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo rev-parse --verify --quiet $toolsCheckout
            if ($LASTEXITCODE -ne 0) {
              & git -c "safe.directory=$toolsRepo" -C $toolsRepo fetch origin $toolsRef 2>$null
              & git -c "safe.directory=$toolsRepo" -C $toolsRepo rev-parse --verify --quiet $toolsRef
              if ($LASTEXITCODE -eq 0) {
                $toolsCheckout = $toolsRef
              } else {
                Write-Warning "tools_ref '$toolsRef' not found; falling back to origin/main"
                $toolsCheckout = "origin/main"
              }
            }
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo reset --hard $toolsCheckout
          } else {
            $toolsRepo = Join-Path $env:GITHUB_WORKSPACE "tools_repo"
            if (Test-Path $toolsRepo) { Remove-Item -Recurse -Force $toolsRepo }
            & git clone $toolsRepoUrl $toolsRepo
            Ensure-OriginHttps -RepoPath $toolsRepo -HttpsUrl $toolsRepoUrl
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo fetch origin --prune
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo show-ref --verify --quiet ("refs/remotes/origin/" + $toolsRef)
            if ($LASTEXITCODE -eq 0) { $toolsCheckout = "origin/$toolsRef" }
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo rev-parse --verify --quiet $toolsCheckout
            if ($LASTEXITCODE -ne 0) {
              & git -c "safe.directory=$toolsRepo" -C $toolsRepo fetch origin $toolsRef 2>$null
              & git -c "safe.directory=$toolsRepo" -C $toolsRepo rev-parse --verify --quiet $toolsRef
              if ($LASTEXITCODE -eq 0) {
                $toolsCheckout = $toolsRef
              } else {
                Write-Warning "tools_ref '$toolsRef' not found in cloned repo; falling back to origin/main"
                $toolsCheckout = "origin/main"
              }
            }
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo reset --hard $toolsCheckout
            $pipeline = Join-Path $toolsRepo "Polish\\pipeline_smoke.ps1"
          }

          $supervisorSrc = Join-Path $toolsRepo "HeadlessBuildSupervisor"
          $supervisorDest = Join-Path $tri "Tools\\HeadlessBuildSupervisor"
          if (Test-Path $supervisorDest) {
            if (Test-Path (Join-Path $supervisorDest ".git")) {
              try {
                Ensure-OriginHttps -RepoPath $supervisorDest -HttpsUrl $toolsRepoUrl
                & git -c "safe.directory=$supervisorDest" -C $supervisorDest fetch origin --prune
                & git -c "safe.directory=$supervisorDest" -C $supervisorDest reset --hard origin/main
              } catch {
              }
            } elseif (Test-Path $supervisorSrc) {
              $srcPath = (Resolve-Path $supervisorSrc).Path
              $destPath = (Resolve-Path $supervisorDest).Path
              if ($srcPath -ne $destPath) {
                Copy-Item -Path (Join-Path $supervisorSrc "*") -Destination $supervisorDest -Recurse -Force
              } else {
                Write-Host "supervisor_sync=skip_same_path"
              }
            }
          }

          # Worktree for the requested ref (keeps caches stable between runs)
          $safe = ($ref -replace '[^A-Za-z0-9_.-]', '_')
          $wtRoot = Join-Path $tri ".tri\\worktrees\\$title"
          New-Item -ItemType Directory -Path $wtRoot -Force | Out-Null
          $wt = Join-Path $wtRoot $safe

          function Invoke-Git {
            param([string[]]$GitArgs, [string]$Context)
            & git @GitArgs
            if ($LASTEXITCODE -ne 0) { throw "git failed: $Context (exit $LASTEXITCODE)" }
          }

          $gitRepoArgs = @('-c', "safe.directory=$repoPath")
          $gitWtArgs = @('-c', "safe.directory=$wt")

          $refExists = $false
          & git @gitRepoArgs -C $repoPath rev-parse --verify $ref 2>$null | Out-Null
          if ($LASTEXITCODE -eq 0) { $refExists = $true }

          if (-not $refExists) {
            Invoke-Git -GitArgs ($gitRepoArgs + @('-C', $repoPath, 'fetch', 'origin', '--prune', '--tags')) -Context "fetch repo"
          }

          $refToCheckout = $ref
          & git @gitRepoArgs -C $repoPath show-ref --verify --quiet "refs/remotes/origin/$ref"
          if ($LASTEXITCODE -eq 0) { $refToCheckout = "origin/$ref" }

          if (Test-Path $wt) {
            if (-not (Test-Path (Join-Path $wt '.git'))) {
              Remove-Item -Recurse -Force $wt
            }
          }

          if (-not (Test-Path $wt)) {
            Invoke-Git -GitArgs ($gitRepoArgs + @('-C', $repoPath, 'worktree', 'add', $wt, $refToCheckout)) -Context "worktree add $refToCheckout"
          } else {
            $headlessManifest = Join-Path $wt "Packages\\manifest.headless.json"
            $headlessLock = Join-Path $wt "Packages\\packages-lock.headless.json"
            if (Test-Path $headlessManifest) {
              Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'checkout', '--', 'Packages/manifest.headless.json')) -Context "reset manifest.headless.json"
            }
            if (Test-Path $headlessLock) {
              Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'checkout', '--', 'Packages/packages-lock.headless.json')) -Context "reset packages-lock.headless.json"
            }
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'fetch', 'origin', '--prune', '--tags')) -Context "fetch worktree"
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'reset', '--hard')) -Context "reset hard (pre-checkout)"
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'checkout', '-f', $refToCheckout)) -Context "checkout $refToCheckout"
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'reset', '--hard')) -Context "reset hard"
          }

          # Ensure local PureDOTS package path resolves under worktrees/<title>
          $puredotsTarget = Join-Path $tri "puredots"
          $puredotsLink = Join-Path $wtRoot "puredots"
          if (-not (Test-Path $puredotsTarget)) {
            Write-Warning "PureDOTS repo missing at $puredotsTarget. Cloning."
            & git clone $puredotsRepoUrl $puredotsTarget
          }
          if (-not (Test-Path (Join-Path $puredotsTarget ".git"))) {
            Write-Warning "PureDOTS repo at $puredotsTarget has no .git. Recloning."
            Remove-Item -Recurse -Force $puredotsTarget
            & git clone $puredotsRepoUrl $puredotsTarget
          }
          if (Test-Path $puredotsTarget) {
            if (-not (Test-Path $puredotsLink)) {
              New-Item -ItemType Junction -Path $puredotsLink -Target $puredotsTarget | Out-Null
            }
          }
          if (Test-Path (Join-Path $puredotsTarget ".git")) {
            $puredotsRef = '${{ inputs.puredots_ref }}'
            Write-Host ("puredots_ref_input={0}" -f $puredotsRef)
            $originExists = & git -C $puredotsTarget remote | Select-String -Pattern '^origin$'
            if ($null -eq $originExists) {
              Invoke-Git -GitArgs @('-C', $puredotsTarget, 'remote', 'add', 'origin', $puredotsRepoUrl) -Context "puredots remote add"
            } else {
              Invoke-Git -GitArgs @('-C', $puredotsTarget, 'remote', 'set-url', 'origin', $puredotsRepoUrl) -Context "puredots remote set-url"
            }
            $puredotsIndexLock = Join-Path $puredotsTarget ".git\\index.lock"
            if (Test-Path $puredotsIndexLock) {
              Remove-Item $puredotsIndexLock -Force
            }
            Invoke-Git -GitArgs @('-C', $puredotsTarget, 'fetch', 'origin', '--prune') -Context "puredots fetch"
            $puredotsCheckout = "origin/main"
            & git -C $puredotsTarget show-ref --verify --quiet "refs/remotes/origin/main"
            if ($LASTEXITCODE -ne 0) { $puredotsCheckout = "origin/HEAD" }
            $puredotsDefault = $puredotsCheckout
            if (-not [string]::IsNullOrWhiteSpace($puredotsRef)) {
              $puredotsCheckout = $puredotsRef
              if ($puredotsRef -match '^[0-9a-fA-F]{7,40}$') {
                Invoke-Git -GitArgs @('-C', $puredotsTarget, 'fetch', 'origin', $puredotsRef) -Context "puredots fetch sha $puredotsRef"
                $puredotsCheckout = $puredotsRef
              } else {
                & git -C $puredotsTarget show-ref --verify --quiet "refs/remotes/origin/$puredotsRef"
                if ($LASTEXITCODE -ne 0) {
                  Invoke-Git -GitArgs @('-C', $puredotsTarget, 'fetch', 'origin', "$puredotsRef:refs/remotes/origin/$puredotsRef") -Context "puredots fetch ref $puredotsRef"
                  & git -C $puredotsTarget show-ref --verify --quiet "refs/remotes/origin/$puredotsRef"
                }
                if ($LASTEXITCODE -eq 0) { $puredotsCheckout = "origin/$puredotsRef" } else { $puredotsCheckout = $puredotsDefault }
              }
            }
            Invoke-Git -GitArgs @('-C', $puredotsTarget, 'reset', '--hard', $puredotsCheckout) -Context "puredots reset $puredotsCheckout"
            Invoke-Git -GitArgs @('-C', $puredotsTarget, 'clean', '-fd') -Context "puredots clean"
            try {
              $refLine = & git -C $puredotsTarget show-ref | Select-String -Pattern "refs/remotes/origin/$puredotsRef"
              Write-Host ("puredots_ref_present={0}" -f ($null -ne $refLine))
            } catch {
              Write-Warning "Failed to check PureDOTS ref presence."
            }
            try {
              $puredotsHead = (& git -C $puredotsTarget rev-parse HEAD)
              Write-Host ("puredots_head={0}" -f $puredotsHead)
            } catch {
              Write-Warning "Failed to read PureDOTS HEAD."
            }
            $compatPath = Join-Path $puredotsTarget "Packages\\com.moni.puredots\\Runtime\\Runtime\\Individual\\AnatomyCompat.cs"
            $legacyPath = Join-Path $puredotsTarget "Packages\\com.moni.puredots\\Runtime\\Individual\\AnatomyComponents.cs"
            Write-Host ("puredots_compat_present={0}" -f (Test-Path $compatPath))
            Write-Host ("puredots_legacy_present={0}" -f (Test-Path $legacyPath))
          }

          # Ensure an embedded-style package junction exists under each worktree.
          $wtPackagesPath = Join-Path $wt "Packages"
          if (-not (Test-Path $wtPackagesPath)) {
            New-Item -ItemType Directory -Path $wtPackagesPath -Force | Out-Null
          }
          $embeddedPkgTarget = Join-Path $puredotsTarget "Packages\\com.moni.puredots"
          $embeddedPkgLink = Join-Path $wtPackagesPath "com.moni.puredots"
          if ((Test-Path $embeddedPkgTarget) -and (-not (Test-Path $embeddedPkgLink))) {
            New-Item -ItemType Junction -Path $embeddedPkgLink -Target $embeddedPkgTarget | Out-Null
          }
          $pkgJunctionPresent = $false
          if (Test-Path $embeddedPkgLink) {
            try {
              $pkgLinkItem = Get-Item -LiteralPath $embeddedPkgLink -Force
              $pkgJunctionPresent = (($pkgLinkItem.Attributes -band [IO.FileAttributes]::ReparsePoint) -ne 0)
            } catch {
              $pkgJunctionPresent = $false
            }
          }
          $shipMicroScenarioPath = Join-Path $embeddedPkgLink "Runtime\\Runtime\\Scenarios\\Samples\\scenario_ship_micro_01.json"
          Write-Host ("puredots_pkg_junction_present={0}" -f $pkgJunctionPresent)
          Write-Host ("puredots_ship_micro_scenario_present={0}" -f (Test-Path $shipMicroScenarioPath))

          # Remove legacy/generated stub duplicates that conflict with Runtime\Stubs
          $puredotsDupes = @(
            "Packages\\com.moni.puredots\\Runtime\\Runtime\\AI\\ConceptStubBehaviourTree.cs",
            "Packages\\com.moni.puredots\\Runtime\\Vehicles\\FighterSquadronStubComponents.cs"
          )
          foreach ($rel in $puredotsDupes) {
            $full = Join-Path $puredotsTarget $rel
            if (Test-Path $full) { Remove-Item -Force $full }
          }

          if ($clean) {
            $paths = @(
              "Library",
              "Library\\Bee",
              "Library\\ScriptAssemblies",
              "Temp",
              "Temp\\BeeArtifacts",
              "Temp\\UnityLockfile",
              "Library\\UnityLockfile"
            )
            foreach ($p in $paths) {
              $full = Join-Path $wt $p
              if (Test-Path $full) { Remove-Item -Recurse -Force $full }
            }
          }

          $queueRoot = '${{ inputs.queue_root }}'
          if ([string]::IsNullOrWhiteSpace($queueRoot)) {
            $queueRoot = "C:\\polish\\anviloop\\$title\\queue"
          }

          $args = @{
            Title = $title
            UnityExe = $env:UNITY_EXE
            ProjectPathOverride = $wt
            QueueRoot = $queueRoot
            Repeat = $repeat
          }
          if ($wait) {
            $args.WaitForResult = $true
            $args.WaitTimeoutSec = $resultWaitTimeoutSec
            Write-Host ("result_wait_timeout_sec={0}" -f $resultWaitTimeoutSec)
          }
          if ($pureGreen) { $args.PureGreen = $true }
          if ($pureGreenPlayMode) {
            $args.PureGreenPlayMode = $true
            if (-not $pureGreen) { $args.PureGreen = $true }
          }
          if (-not [string]::IsNullOrWhiteSpace($scenarioRel)) { $args.ScenarioRel = $scenarioRel }
          if (-not [string]::IsNullOrWhiteSpace($scenarioId)) { $args.ScenarioId = $scenarioId }
          if (-not [string]::IsNullOrWhiteSpace($envJson)) { $args.EnvJson = $envJson }

          $env:GIT_COMMIT = $ref
          $env:GIT_BRANCH = $ref

          $log = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke.log"
          & $pipeline @args 2>&1 | Tee-Object -FilePath $log
          # Determine success from pipeline_smoke summary to avoid leaked native exit codes.
          $summary = Join-Path $queueRoot "reports\\pipeline_smoke_summary_latest.md"
          $summaryCopy = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke_summary_latest.md"
          if (Test-Path $summary) {
            Add-Content -Path $summary -Value "* workflow_state: completed"
            Copy-Item -Path $summary -Destination $summaryCopy -Force
            $summaryText = Get-Content $summaryCopy -Raw
            if ($summaryText -match '(?m)^\* status: FAIL') {
              throw "pipeline_smoke reported FAIL (see $summaryCopy)"
            }
          } else {
            throw "pipeline_smoke summary missing: $summary"
          }
          # Clear any leaked native exit code so the workflow reflects the pipeline result.
          $global:LASTEXITCODE = 0
          exit 0

      - name: Collect diagnostics (always)
        if: ${{ always() }}
        continue-on-error: true
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Continue"

          $title = '${{ inputs.title }}'
          $queueRoot = '${{ inputs.queue_root }}'
          if ([string]::IsNullOrWhiteSpace($queueRoot)) {
            $queueRoot = "C:\\polish\\anviloop\\$title\\queue"
          }

          $diagRoot = Join-Path $env:GITHUB_WORKSPACE "buildbox_diag"
          if (Test-Path $diagRoot) { Remove-Item -Recurse -Force $diagRoot }
          New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null

          $pipelineLog = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke.log"
          if (Test-Path $pipelineLog) { Copy-Item $pipelineLog -Destination $diagRoot -Force }

          $summary = Join-Path $queueRoot "reports\\pipeline_smoke_summary_latest.md"
          if (Test-Path $summary) { Copy-Item $summary -Destination $diagRoot -Force }
          $workflowState = Join-Path $diagRoot "workflow_state.txt"
          "workflow_state=completed" | Set-Content -Path $workflowState
          $summaryCopy = Join-Path $diagRoot "pipeline_smoke_summary_latest.md"
          if (Test-Path $summaryCopy) {
            Add-Content -Path $summaryCopy -Value "* workflow_state: completed"
          }

          $buildId = $null
          $buildReportPath = $null
          $missingScriptsPath = $null
          $pptrScanPath = $null
          $pptrFileIdReport = $null
          if (Test-Path $summary) {
            $summaryText = Get-Content $summary -Raw
            if ($summaryText -match '(?m)^\* build_id:\s*(\S+)') { $buildId = $matches[1] }
            if ($summaryText -match '(?m)([A-Za-z]:\\[^\r\n]+HeadlessMissingScripts\.log)') { $missingScriptsPath = $matches[1] }
            if ($summaryText -match '(?m)([A-Za-z]:\\[^\r\n]+PPtrCastScan\.log)') { $pptrScanPath = $matches[1] }
            if ($summaryText -match '(?m)^\* pptr_scan_report:\s*([A-Za-z]:\\[^\r\n]+)') { $pptrFileIdReport = $matches[1] }
            if ($summaryText -match '(?m)([A-Za-z]:\\[^\r\n]+\.log)') { $buildReportPath = $matches[1] }
          }
          if ($buildReportPath -and (Test-Path $buildReportPath)) {
            $buildOutDir = Join-Path $diagRoot "build"
            if (-not (Test-Path $buildOutDir)) { New-Item -ItemType Directory -Path $buildOutDir -Force | Out-Null }
            $buildReportCopy = Join-Path $buildOutDir ([IO.Path]::GetFileName($buildReportPath))
            Copy-Item -Path $buildReportPath -Destination $buildReportCopy -Force
            Get-Content -Path $buildReportCopy -Tail 400 | Set-Content -Path ($buildReportCopy + ".tail.log")

            $buildDir = Split-Path $buildReportPath -Parent
            if (Test-Path $buildDir) {
              Get-ChildItem -Path $buildDir -Filter "*HeadlessBuildFailure*.log" -ErrorAction SilentlyContinue | ForEach-Object {
                $failureCopy = Join-Path $buildOutDir $_.Name
                Copy-Item -Path $_.FullName -Destination $failureCopy -Force
                Get-Content -Path $failureCopy -Tail 400 | Set-Content -Path ($failureCopy + ".tail.log")
              }
              Get-ChildItem -Path $buildDir -Filter "*HeadlessEditor.log" -ErrorAction SilentlyContinue | ForEach-Object {
                $editorCopy = Join-Path $buildOutDir $_.Name
                Copy-Item -Path $_.FullName -Destination $editorCopy -Force
                Get-Content -Path $editorCopy -Tail 800 | Set-Content -Path ($editorCopy + ".tail.log")
              }
            }
          }

          if ($missingScriptsPath -and (Test-Path $missingScriptsPath)) {
            $buildOutDir = Join-Path $diagRoot "build"
            if (-not (Test-Path $buildOutDir)) { New-Item -ItemType Directory -Path $buildOutDir -Force | Out-Null }
            $missingCopy = Join-Path $buildOutDir ([IO.Path]::GetFileName($missingScriptsPath))
            Copy-Item -Path $missingScriptsPath -Destination $missingCopy -Force
          }
          if ($pptrScanPath -and (Test-Path $pptrScanPath)) {
            $buildOutDir = Join-Path $diagRoot "build"
            if (-not (Test-Path $buildOutDir)) { New-Item -ItemType Directory -Path $buildOutDir -Force | Out-Null }
            $pptrCopy = Join-Path $buildOutDir ([IO.Path]::GetFileName($pptrScanPath))
            Copy-Item -Path $pptrScanPath -Destination $pptrCopy -Force
          }
          if ($pptrFileIdReport -and (Test-Path $pptrFileIdReport)) {
            $buildOutDir = Join-Path $diagRoot "build"
            if (-not (Test-Path $buildOutDir)) { New-Item -ItemType Directory -Path $buildOutDir -Force | Out-Null }
            $fileIdCopy = Join-Path $buildOutDir ([IO.Path]::GetFileName($pptrFileIdReport))
            Copy-Item -Path $pptrFileIdReport -Destination $fileIdCopy -Force
          }

          $zipPaths = New-Object System.Collections.Generic.List[string]
          if (Test-Path $pipelineLog) {
            $artifactLines = Select-String -Path $pipelineLog -Pattern 'artifact=([A-Za-z]:\\[^\s]+\.zip)' -AllMatches
            foreach ($line in $artifactLines) {
              foreach ($m in $line.Matches) {
                $zipPaths.Add($m.Groups[1].Value)
              }
            }
          }

          $resultsDir = Join-Path $queueRoot "results"
          if (Test-Path $resultsDir) {
            $z = Get-ChildItem -Path $resultsDir -Filter "result_*.zip" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 3
            foreach ($zip in $z) { $zipPaths.Add($zip.FullName) }
          }

          $artifactsDir = Join-Path $queueRoot "artifacts"
          if (Test-Path $artifactsDir) {
            $z = Get-ChildItem -Path $artifactsDir -Filter "artifact_*.zip" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 3
            foreach ($zip in $z) { $zipPaths.Add($zip.FullName) }
          }

          $zipPaths = $zipPaths | Where-Object { Test-Path $_ } | Sort-Object -Unique
          $zipFiles = @()
          foreach ($p in $zipPaths) {
            $fi = Get-Item -LiteralPath $p -ErrorAction SilentlyContinue
            if ($fi) { $zipFiles += $fi }
          }
          $zipFiles = $zipFiles | Sort-Object LastWriteTime -Descending
          Write-Host ("diag: found {0} zip(s)" -f $zipFiles.Count)

          $summaryPath = Join-Path $diagRoot "diag_summary.txt"
          $summaryLines = @()
          $summaryLines += "zip_count=$($zipFiles.Count)"

          $wanted = @(
            "meta.json",
            "out/watchdog.json",
            "out/run_summary.json",
            "out/invariants.json",
            "out/stdout.log",
            "out/stderr.log",
            "out/player.log",
            "out/unity.log",
            "out/diag_stdout_tail.txt",
            "out/diag_stderr_tail.txt",
            "logs/stdout.log",
            "logs/stderr.log",
            "logs/player.log",
            "logs/unity.log",
            "logs/primary_error_snippet.txt",
            "logs/unity_build_tail.txt",
            "build_outcome.json",
            "build/Space4X_HeadlessPPtrCastScan.log"
          )
          $wantedNames = @(
            "meta.json",
            "watchdog.json",
            "run_summary.json",
            "invariants.json",
            "out_watchdog.json",
            "out_run_summary.json",
            "out_invariants.json",
            "stdout.log",
            "stderr.log",
            "player.log",
            "unity.log",
            "diag_stdout_tail.txt",
            "diag_stderr_tail.txt"
          )
          $wantedRegex = "(?i)(^|/)crash/.*\\.log$"
          $extraLogRegex = "(?i)(^|/)(unity_full_.*\\.log|unity_build\\.log|unity_stdout_.*\\.log|unity_stderr_.*\\.log)$"
          $buildReportRegex = "(?i)(^|/)build/.*HeadlessBuildReport.*\\.log$"
          $buildFailureRegex = "(?i)(^|/)build/.*HeadlessBuildFailure.*\\.log$"
          $buildPPtrRegex = "(?i)(^|/)build/.*PPtrCastScan.*\\.log$"
          $logNameRegex = "(?i)(stdout|stderr|player|unity|unity_full_.*|unity_build|unity_stdout_.*|unity_stderr_.*)\\.log$"
          $logPathRegex = "(?i)(^|/)(stdout|stderr|player|unity|unity_full_.*|unity_build|unity_stdout_.*|unity_stderr_.*)\\.log$"
          $crashLogRegex = "(?i)(^|/)crash/.*\\.log$"
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zipSample = $zipFiles | Select-Object -First 2
          $zipIndex = 0
          foreach ($zipFile in $zipSample) {
            $zipIndex++
            $zipPath = $zipFile.FullName
            $zipName = [IO.Path]::GetFileNameWithoutExtension($zipPath)
            $dest = Join-Path $diagRoot ("results\\" + $zipName)
            New-Item -ItemType Directory -Path $dest -Force | Out-Null
            $archive = $null
            $jsonEntries = New-Object System.Collections.Generic.List[string]
            $matchEntries = New-Object System.Collections.Generic.List[string]
            try {
              $archive = [IO.Compression.ZipFile]::OpenRead($zipPath)
              foreach ($entry in $archive.Entries) {
                if ($entry.Name -match "(?i)\\.json$") { $jsonEntries.Add($entry.FullName) }
                $matchFull = $wanted -contains $entry.FullName
                $matchName = $wantedNames -contains $entry.Name
                $matchRegex = ($entry.FullName -match $wantedRegex) -or ($entry.Name -match $wantedRegex) -or ($entry.FullName -match $extraLogRegex) -or ($entry.Name -match $extraLogRegex) -or ($entry.FullName -match $buildReportRegex) -or ($entry.Name -match $buildReportRegex) -or ($entry.FullName -match $buildFailureRegex) -or ($entry.Name -match $buildFailureRegex) -or ($entry.FullName -match $buildPPtrRegex) -or ($entry.Name -match $buildPPtrRegex)
                if ($matchFull -or $matchName -or $matchRegex) {
                  $matchEntries.Add($entry.FullName)
                  $relative = if ($matchFull) { ($entry.FullName -replace '/', '\\') } else { ("flat\\" + $entry.Name) }
                  $outPath = Join-Path $dest $relative
                  $outDir = Split-Path $outPath -Parent
                  if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir -Force | Out-Null }
                  [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $outPath, $true)

                  $isLog = ($entry.Name -match $logNameRegex) -or ($entry.FullName -match $logPathRegex) -or ($entry.FullName -match $crashLogRegex)
                  if ($isLog -and (Test-Path $outPath)) {
                    $tailDir = Join-Path $dest "log_tails"
                    if (-not (Test-Path $tailDir)) { New-Item -ItemType Directory -Path $tailDir -Force | Out-Null }
                    $tailBase = ($entry.FullName -replace '[\\\\/:*?\"<>|]', '_')
                    $tailPath = Join-Path $tailDir ($tailBase + ".tail.log")
                    Get-Content -Path $outPath -Tail 400 -ErrorAction SilentlyContinue | Set-Content -Path $tailPath
                  }
                }
              }
            } finally {
              if ($archive) { $archive.Dispose() }
            }
            $summaryLines += ("zip[{0}]={1} json_count={2} match_count={3}" -f $zipIndex, $zipFile.Name, $jsonEntries.Count, $matchEntries.Count)
            foreach ($name in ($jsonEntries | Select-Object -First 10)) { $summaryLines += ("  json: " + $name) }
            foreach ($name in ($matchEntries | Select-Object -First 10)) { $summaryLines += ("  match: " + $name) }
          }

          $reportsDir = Join-Path $queueRoot "reports"
          if (Test-Path $reportsDir) {
            $reportsOut = Join-Path $diagRoot "reports"
            New-Item -ItemType Directory -Path $reportsOut -Force | Out-Null
            Get-ChildItem -Path $reportsDir -Filter "triage_*.json" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 5 |
              Copy-Item -Destination $reportsOut -Force
          }

          if ($buildId) {
            $stagingRoot = Join-Path $queueRoot "artifacts"
            if (Test-Path $stagingRoot) {
              $staging = Get-ChildItem -Path $stagingRoot -Directory -Filter ("staging_" + $buildId + "*") -ErrorAction SilentlyContinue |
                Sort-Object LastWriteTime -Descending | Select-Object -First 1
              if ($staging) {
                $stagingOut = Join-Path $diagRoot "staging"
                New-Item -ItemType Directory -Path $stagingOut -Force | Out-Null
                Get-ChildItem -Path $staging.FullName -Recurse -Filter "build_outcome.json" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "logs") -Filter "unity_build_tail.txt" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*HeadlessBuildReport*.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*HeadlessBuildFailure*.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*HeadlessMissingScripts.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*PPtrCastScan*.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                $stagingLogs = Join-Path $staging.FullName "logs"
                $logPatterns = @("unity_full_*.log", "unity_stdout_*.log", "unity_stderr_*.log", "unity_build.log")
                foreach ($pattern in $logPatterns) {
                  Get-ChildItem -Path $stagingLogs -Filter $pattern -ErrorAction SilentlyContinue | ForEach-Object {
                    $dest = Join-Path $stagingOut $_.Name
                    Copy-Item -Path $_.FullName -Destination $dest -Force
                    Get-Content -Path $dest -Tail 400 -ErrorAction SilentlyContinue | Set-Content -Path ($dest + ".tail.log")
                  }
                }
              }
            }
          }

          $summarizer = Join-Path $env:TRI_ROOT "Tools\\HeadlessRebuildTool\\Polish\\Ops\\diag_summarize.ps1"
          if (Test-Path $summarizer) {
            $resultRoots = Get-ChildItem -Path (Join-Path $diagRoot "results") -Directory -ErrorAction SilentlyContinue
            foreach ($root in $resultRoots) {
              if (Test-Path (Join-Path $root.FullName "meta.json")) {
                try {
                  & $summarizer -ResultDir $root.FullName | Out-Null
                } catch {
                }
              }
            }
          }

          $summaryLines | Set-Content -Path $summaryPath

          $logsRoot = "C:\\polish\\anviloop\\logs"
          $logNames = @(
            "watchdog_heartbeat.log",
            "watch_daemon_${title}.log",
            "wsl_runner_${title}.log",
            "intel_${title}.log"
          )
          foreach ($ln in $logNames) {
            $path = Join-Path $logsRoot $ln
            if (Test-Path $path) {
              $dest = Join-Path $diagRoot ("logs\\" + $ln)
              $destDir = Split-Path $dest -Parent
              if (-not (Test-Path $destDir)) { New-Item -ItemType Directory -Path $destDir -Force | Out-Null }
              Get-Content -Path $path -Tail 500 | Set-Content -Path $dest
            }
          }

          # Extract compiler errors into a single easy-to-scan file.
          $compileOut = Join-Path $diagRoot "compiler_errors.txt"
          $compileLines = @()
          $compileLines += "compiler_error_scan_root=$diagRoot"
          $compileLines += "pattern=error CS#### (case-insensitive)"
          $candidateLogs = Get-ChildItem -Path $diagRoot -Recurse -File -Include *.log,*.txt -ErrorAction SilentlyContinue
          foreach ($log in $candidateLogs) {
            try {
              $hits = Select-String -Path $log.FullName -Pattern 'error\\s+CS\\d{4,5}' -AllMatches -Context 2,2 -ErrorAction SilentlyContinue
              if ($hits) {
                $compileLines += "file=" + $log.FullName
                foreach ($hit in $hits) { $compileLines += $hit.ToString() }
              }
            } catch {
            }
          }
          if ($compileLines.Count -gt 2) {
            $compileLines | Set-Content -Path $compileOut
          } else {
            "no compiler errors found" | Set-Content -Path $compileOut
          }

          # Extract first meaningful build error signature for quick triage.
          $errorSummary = Join-Path $diagRoot "build_error_summary.txt"
          $sigPatterns = @(
            "PPtr cast failed",
            "Missing (Mono)?Script",
            "error\s+CS\d{4,5}",
            "Bee\.\w+Exception",
            "ScriptCompilation",
            "Build failed",
            "ExecuteMethod",
            "UnityException"
          )
          $firstHit = $null
          foreach ($pattern in $sigPatterns) {
            foreach ($log in $candidateLogs) {
              try {
                $hit = Select-String -Path $log.FullName -Pattern $pattern -Context 3,6 -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($hit) {
                  $firstHit = @(
                    "pattern=$pattern",
                    "file=$($log.FullName)",
                    $hit.ToString()
                  )
                  break
                }
              } catch {
              }
            }
            if ($firstHit) { break }
          }
          if ($firstHit) {
            $firstHit | Set-Content -Path $errorSummary
          } else {
            "no build error signature found" | Set-Content -Path $errorSummary
          }

          # Missing script triage: extract asset paths from logs.
          $missingScriptsOut = Join-Path $diagRoot "missing_scripts.txt"
          $missingLines = @()
          foreach ($log in $candidateLogs) {
            try {
              $hits = Select-String -Path $log.FullName -Pattern "Missing script asset:" -AllMatches -ErrorAction SilentlyContinue
              if ($hits) {
                foreach ($hit in $hits) {
                  $missingLines += $hit.ToString()
                }
              }
            } catch {
            }
          }
          if ($missingLines.Count -gt 0) {
            $missingLines | Set-Content -Path $missingScriptsOut
          } else {
            "no missing script assets found in logs" | Set-Content -Path $missingScriptsOut
          }

      - name: Upload pipeline log
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: pipeline_log
          path: pipeline_smoke.log

      - name: Upload diagnostics
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: buildbox_diag_${{ inputs.title }}_${{ github.run_id }}
          path: buildbox_diag
          retention-days: 14

      - name: Emit quick proof (if available)
        if: ${{ always() }}
        continue-on-error: true
        shell: pwsh
        run: |
          $proof = Join-Path $env:TRI_ROOT "Tools\HeadlessRebuildTool\Polish\Ops\artifact_proof.ps1"
          if (-not (Test-Path $proof)) {
            $proof = Join-Path $env:TRI_ROOT "Tools\Polish\Ops\artifact_proof.ps1"
          }
          if (Test-Path $proof) {
            $outFile = Join-Path $env:GITHUB_WORKSPACE "buildbox_diag\\proof.txt"
            & $proof -RunId $env:GITHUB_RUN_ID -Title '${{ inputs.title }}' -OutFile $outFile
          } else {
            Write-Host "artifact_proof not found on buildbox tools repo"
          }

# noop touch for workflow_dispatch registration
