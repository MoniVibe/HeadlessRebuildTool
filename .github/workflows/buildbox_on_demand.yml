name: "Buildbox: on-demand rebuild + headless sim"

on:
  workflow_dispatch:
    inputs:
      title:
        description: "Which project"
        type: choice
        options: [space4x, godgame]
        required: true
      ref:
        description: "Git ref/branch/SHA to test (must be pushed to GitHub)"
        required: true
        default: "main"
      repeat:
        description: "Repeat runs"
        required: true
        default: "1"
      wait_for_result:
        description: "Wait for result zips"
        type: boolean
        required: true
        default: true
      clean_cache:
        description: "Clear Bee/lock caches in the worktree before build"
        type: boolean
        required: true
        default: false
      queue_root:
        description: "Optional override queue root (blank = default C:\\polish\\anviloop\\<title>\\queue)"
        required: false
        default: ""

permissions:
  contents: read

concurrency:
  group: buildbox-${{ inputs.title }}
  cancel-in-progress: false

jobs:
  run:
    runs-on: [self-hosted, buildbox]
    timeout-minutes: 240

    steps:
      - name: Run pipeline on desktop (local Tri install)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $title = '${{ inputs.title }}'
          $ref   = '${{ inputs.ref }}'
          $repeat = [int]'${{ inputs.repeat }}'
          $wait   = '${{ inputs.wait_for_result }}' -eq 'true'
          $clean  = '${{ inputs.clean_cache }}' -eq 'true'

          if ([string]::IsNullOrWhiteSpace($env:TRI_ROOT)) { throw "Missing TRI_ROOT env var on desktop." }
          if ([string]::IsNullOrWhiteSpace($env:UNITY_EXE)) { throw "Missing UNITY_EXE env var on desktop." }
          if (-not (Test-Path $env:UNITY_EXE)) { throw "UNITY_EXE not found: $env:UNITY_EXE" }

          $tri = $env:TRI_ROOT

          # Local repos expected at: TRI_ROOT\space4x and TRI_ROOT\godgame
          $repoPath = Join-Path $tri $title
          if (-not (Test-Path $repoPath)) { throw "Repo missing: $repoPath" }

          # Local tools expected at: TRI_ROOT\Tools\HeadlessRebuildTool\Polish\pipeline_smoke.ps1
          $pipeline = Join-Path $tri "Tools\\HeadlessRebuildTool\\Polish\\pipeline_smoke.ps1"
          if (-not (Test-Path $pipeline)) { throw "pipeline_smoke.ps1 not found: $pipeline" }

          # Worktree for the requested ref (keeps caches stable between runs)
          $safe = ($ref -replace '[^A-Za-z0-9_.-]', '_')
          $wtRoot = Join-Path $tri ".tri\\worktrees\\$title"
          New-Item -ItemType Directory -Path $wtRoot -Force | Out-Null
          $wt = Join-Path $wtRoot $safe

          $gitRepoArgs = @('-c', "safe.directory=$repoPath")
          $gitWtArgs = @('-c', "safe.directory=$wt")

          $refExists = $false
          & git @gitRepoArgs -C $repoPath rev-parse --verify $ref 2>$null | Out-Null
          if ($LASTEXITCODE -eq 0) { $refExists = $true }

          if (-not $refExists) {
            & git @gitRepoArgs -C $repoPath fetch --all --tags 2>$null
          }

          if (-not (Test-Path $wt)) {
            $worktreeAdd = & git @gitRepoArgs -C $repoPath worktree add $wt $ref 2>&1
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "worktree add failed: $worktreeAdd"
              $wt = $repoPath
            }
          } else {
            & git @gitWtArgs -C $wt fetch --all --tags 2>$null
            & git @gitWtArgs -C $wt checkout $ref
            & git @gitWtArgs -C $wt reset --hard
          }

          if ($clean) {
            $paths = @(
              "Library\\Bee",
              "Library\\ScriptAssemblies",
              "Temp\\BeeArtifacts",
              "Temp\\UnityLockfile",
              "Library\\UnityLockfile"
            )
            foreach ($p in $paths) {
              $full = Join-Path $wt $p
              if (Test-Path $full) { Remove-Item -Recurse -Force $full }
            }
          }

          $queueRoot = '${{ inputs.queue_root }}'
          if ([string]::IsNullOrWhiteSpace($queueRoot)) {
            $queueRoot = "C:\\polish\\anviloop\\$title\\queue"
          }

          $args = @{
            Title = $title
            UnityExe = $env:UNITY_EXE
            ProjectPathOverride = $wt
            QueueRoot = $queueRoot
            Repeat = $repeat
          }
          if ($wait) { $args.WaitForResult = $true }

          $log = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke.log"
          & $pipeline @args 2>&1 | Tee-Object -FilePath $log
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      - name: Collect diagnostics (always)
        if: ${{ always() }}
        continue-on-error: true
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Continue"

          $title = '${{ inputs.title }}'
          $queueRoot = '${{ inputs.queue_root }}'
          if ([string]::IsNullOrWhiteSpace($queueRoot)) {
            $queueRoot = "C:\\polish\\anviloop\\$title\\queue"
          }

          $diagRoot = Join-Path $env:GITHUB_WORKSPACE "buildbox_diag"
          New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null

          $pipelineLog = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke.log"
          if (Test-Path $pipelineLog) { Copy-Item $pipelineLog -Destination $diagRoot -Force }

          $summary = Join-Path $queueRoot "reports\\pipeline_smoke_summary_latest.md"
          if (Test-Path $summary) { Copy-Item $summary -Destination $diagRoot -Force }

          $zipPaths = New-Object System.Collections.Generic.List[string]
          if (Test-Path $pipelineLog) {
            $artifactLines = Select-String -Path $pipelineLog -Pattern 'artifact=([A-Za-z]:\\\\[^\\s]+\\.zip)' -AllMatches
            foreach ($line in $artifactLines) {
              foreach ($m in $line.Matches) {
                $zipPaths.Add($m.Groups[1].Value)
              }
            }
          }

          $resultsDir = Join-Path $queueRoot "results"
          if (Test-Path $resultsDir) {
            $z = Get-ChildItem -Path $resultsDir -Filter "result_*.zip" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 3
            foreach ($zip in $z) { $zipPaths.Add($zip.FullName) }
          }

          $artifactsDir = Join-Path $queueRoot "artifacts"
          if (Test-Path $artifactsDir) {
            $z = Get-ChildItem -Path $artifactsDir -Filter "artifact_*.zip" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 3
            foreach ($zip in $z) { $zipPaths.Add($zip.FullName) }
          }

          $zipPaths = $zipPaths | Where-Object { Test-Path $_ } | Sort-Object -Unique
          $zipFiles = @()
          foreach ($p in $zipPaths) {
            $fi = Get-Item -LiteralPath $p -ErrorAction SilentlyContinue
            if ($fi) { $zipFiles += $fi }
          }
          $zipFiles = $zipFiles | Sort-Object LastWriteTime -Descending
          Write-Host ("diag: found {0} zip(s)" -f $zipFiles.Count)

          $wanted = @("meta.json", "out/watchdog.json", "out/run_summary.json", "out/invariants.json")
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          foreach ($zipFile in $zipFiles) {
            $zipPath = $zipFile.FullName
            $zipName = [IO.Path]::GetFileNameWithoutExtension($zipPath)
            $dest = Join-Path $diagRoot ("results\\" + $zipName)
            New-Item -ItemType Directory -Path $dest -Force | Out-Null
            $archive = $null
            try {
              $archive = [IO.Compression.ZipFile]::OpenRead($zipPath)
              foreach ($entry in $archive.Entries) {
                if ($wanted -contains $entry.FullName) {
                  $outPath = Join-Path $dest ($entry.FullName -replace '/', '\\')
                  $outDir = Split-Path $outPath -Parent
                  if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir -Force | Out-Null }
                  $entry.ExtractToFile($outPath, $true)
                }
              }
            } finally {
              if ($archive) { $archive.Dispose() }
            }
          }

          $zipOutDir = Join-Path $diagRoot "zips"
          New-Item -ItemType Directory -Path $zipOutDir -Force | Out-Null
          foreach ($zipFile in ($zipFiles | Select-Object -First 2)) {
            Copy-Item -LiteralPath $zipFile.FullName -Destination (Join-Path $zipOutDir $zipFile.Name) -Force
          }

          $reportsDir = Join-Path $queueRoot "reports"
          if (Test-Path $reportsDir) {
            $reportsOut = Join-Path $diagRoot "reports"
            New-Item -ItemType Directory -Path $reportsOut -Force | Out-Null
            Get-ChildItem -Path $reportsDir -Filter "triage_*.json" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 5 |
              Copy-Item -Destination $reportsOut -Force
          }

          $logsRoot = "C:\\polish\\anviloop\\logs"
          $logNames = @(
            "watchdog_heartbeat.log",
            "watch_daemon_${title}.log",
            "wsl_runner_${title}.log",
            "intel_${title}.log"
          )
          foreach ($ln in $logNames) {
            $path = Join-Path $logsRoot $ln
            if (Test-Path $path) {
              $dest = Join-Path $diagRoot ("logs\\" + $ln)
              $destDir = Split-Path $dest -Parent
              if (-not (Test-Path $destDir)) { New-Item -ItemType Directory -Path $destDir -Force | Out-Null }
              Get-Content -Path $path -Tail 500 | Set-Content -Path $dest
            }
          }

      - name: Upload pipeline log
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: pipeline_log
          path: pipeline_smoke.log

      - name: Upload diagnostics
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: buildbox_diag_${{ inputs.title }}_${{ github.run_id }}
          path: buildbox_diag
          retention-days: 14

# noop touch for workflow_dispatch registration
