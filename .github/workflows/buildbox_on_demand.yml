name: "Buildbox: on-demand rebuild + headless sim"

on:
  workflow_dispatch:
    inputs:
      title:
        description: "Which project"
        type: choice
        options: [space4x, godgame]
        required: true
      ref:
        description: "Git ref/branch/SHA to test (must be pushed to GitHub)"
        required: true
        default: "main"
      repeat:
        description: "Repeat runs"
        required: true
        default: "1"
      wait_for_result:
        description: "Wait for result zips"
        type: boolean
        required: true
        default: true
      clean_cache:
        description: "Clear Bee/lock caches in the worktree before build"
        type: boolean
        required: true
        default: false
      queue_root:
        description: "Optional override queue root (blank = default C:\\polish\\anviloop\\<title>\\queue)"
        required: false
        default: ""
      puredots_ref:
        description: "Optional PureDOTS ref/branch/SHA (blank = origin/fix/ai-stubs-guard)"
        required: false
        default: ""
      scenario_rel:
        description: "Optional scenario rel path (Assets/... or Packages/...)"
        required: false
        default: ""

permissions:
  contents: read

concurrency:
  group: buildbox-${{ inputs.title }}
  cancel-in-progress: false

jobs:
  run:
    runs-on: [self-hosted, buildbox]
    timeout-minutes: 240

    steps:
      - name: Run pipeline on desktop (local Tri install)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $title = '${{ inputs.title }}'
          $ref   = '${{ inputs.ref }}'
          $repeat = [int]'${{ inputs.repeat }}'
          $wait   = '${{ inputs.wait_for_result }}' -eq 'true'
          $clean  = '${{ inputs.clean_cache }}' -eq 'true'
          $scenarioRel = '${{ inputs.scenario_rel }}'

          if ([string]::IsNullOrWhiteSpace($env:TRI_ROOT)) { throw "Missing TRI_ROOT env var on desktop." }
          if ([string]::IsNullOrWhiteSpace($env:UNITY_EXE)) { throw "Missing UNITY_EXE env var on desktop." }
          if (-not (Test-Path $env:UNITY_EXE)) { throw "UNITY_EXE not found: $env:UNITY_EXE" }

          $tri = $env:TRI_ROOT

          # Local repos expected at: TRI_ROOT\space4x and TRI_ROOT\godgame
          $repoPath = Join-Path $tri $title
          if (-not (Test-Path $repoPath)) { throw "Repo missing: $repoPath" }

          # Local tools expected at: TRI_ROOT\Tools\HeadlessRebuildTool\Polish\pipeline_smoke.ps1
          $pipeline = Join-Path $tri "Tools\\HeadlessRebuildTool\\Polish\\pipeline_smoke.ps1"
          if (-not (Test-Path $pipeline)) {
            $pipeline = Join-Path $tri "Tools\\Polish\\pipeline_smoke.ps1"
          }
          if (-not (Test-Path $pipeline)) { throw "pipeline_smoke.ps1 not found: $pipeline" }

          $toolsRepo = Split-Path -Parent $pipeline
          $toolsRepo = Split-Path -Parent $toolsRepo
          if (Test-Path (Join-Path $toolsRepo ".git")) {
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo fetch --all --prune
            & git -c "safe.directory=$toolsRepo" -C $toolsRepo reset --hard origin/main
          } else {
            $toolsRepo = Join-Path $env:GITHUB_WORKSPACE "tools_repo"
            if (Test-Path $toolsRepo) { Remove-Item -Recurse -Force $toolsRepo }
            & git clone "https://github.com/MoniVibe/HeadlessRebuildTool.git" $toolsRepo
            $pipeline = Join-Path $toolsRepo "Polish\\pipeline_smoke.ps1"
          }

          $supervisorSrc = Join-Path $toolsRepo "HeadlessBuildSupervisor"
          $supervisorDest = Join-Path $tri "Tools\\HeadlessBuildSupervisor"
          if (Test-Path $supervisorDest) {
            if (Test-Path (Join-Path $supervisorDest ".git")) {
              try {
                & git -c "safe.directory=$supervisorDest" -C $supervisorDest fetch --all --prune
                & git -c "safe.directory=$supervisorDest" -C $supervisorDest reset --hard origin/main
              } catch {
              }
            } elseif (Test-Path $supervisorSrc) {
              Copy-Item -Path (Join-Path $supervisorSrc "*") -Destination $supervisorDest -Recurse -Force
            }
          }

          # Worktree for the requested ref (keeps caches stable between runs)
          $safe = ($ref -replace '[^A-Za-z0-9_.-]', '_')
          $wtRoot = Join-Path $tri ".tri\\worktrees\\$title"
          New-Item -ItemType Directory -Path $wtRoot -Force | Out-Null
          $wt = Join-Path $wtRoot $safe

          function Invoke-Git {
            param([string[]]$GitArgs, [string]$Context)
            & git @GitArgs
            if ($LASTEXITCODE -ne 0) { throw "git failed: $Context (exit $LASTEXITCODE)" }
          }

          $gitRepoArgs = @('-c', "safe.directory=$repoPath")
          $gitWtArgs = @('-c', "safe.directory=$wt")

          $refExists = $false
          & git @gitRepoArgs -C $repoPath rev-parse --verify $ref 2>$null | Out-Null
          if ($LASTEXITCODE -eq 0) { $refExists = $true }

          if (-not $refExists) {
            Invoke-Git -GitArgs ($gitRepoArgs + @('-C', $repoPath, 'fetch', '--all', '--tags')) -Context "fetch repo"
          }

          $refToCheckout = $ref
          & git @gitRepoArgs -C $repoPath show-ref --verify --quiet "refs/remotes/origin/$ref"
          if ($LASTEXITCODE -eq 0) { $refToCheckout = "origin/$ref" }

          if (-not (Test-Path $wt)) {
            Invoke-Git -GitArgs ($gitRepoArgs + @('-C', $repoPath, 'worktree', 'add', $wt, $refToCheckout)) -Context "worktree add $refToCheckout"
          } else {
            if (-not (Test-Path (Join-Path $wt '.git'))) {
              throw "Worktree path exists but is not a git worktree: $wt"
            }
            $headlessManifest = Join-Path $wt "Packages\\manifest.headless.json"
            $headlessLock = Join-Path $wt "Packages\\packages-lock.headless.json"
            if (Test-Path $headlessManifest) {
              Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'checkout', '--', 'Packages/manifest.headless.json')) -Context "reset manifest.headless.json"
            }
            if (Test-Path $headlessLock) {
              Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'checkout', '--', 'Packages/packages-lock.headless.json')) -Context "reset packages-lock.headless.json"
            }
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'fetch', '--all', '--tags')) -Context "fetch worktree"
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'reset', '--hard')) -Context "reset hard (pre-checkout)"
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'checkout', '-f', $refToCheckout)) -Context "checkout $refToCheckout"
            Invoke-Git -GitArgs ($gitWtArgs + @('-C', $wt, 'reset', '--hard')) -Context "reset hard"
          }

          # Ensure local PureDOTS package path resolves under worktrees/<title>
          $puredotsTarget = Join-Path $tri "puredots"
          $puredotsLink = Join-Path $wtRoot "puredots"
          if (Test-Path $puredotsTarget) {
            if (-not (Test-Path $puredotsLink)) {
              New-Item -ItemType Junction -Path $puredotsLink -Target $puredotsTarget | Out-Null
            }
          }
          if (Test-Path (Join-Path $puredotsTarget ".git")) {
            $puredotsRef = '${{ inputs.puredots_ref }}'
            & git -C $puredotsTarget fetch --all --prune
            $puredotsCheckout = "origin/fix/ai-stubs-guard"
            if (-not [string]::IsNullOrWhiteSpace($puredotsRef)) {
              $puredotsCheckout = $puredotsRef
              & git -C $puredotsTarget show-ref --verify --quiet "refs/remotes/origin/$puredotsRef"
              if ($LASTEXITCODE -eq 0) { $puredotsCheckout = "origin/$puredotsRef" }
            }
            & git -C $puredotsTarget reset --hard $puredotsCheckout
            & git -C $puredotsTarget clean -fd
          }
          # Remove legacy/generated stub duplicates that conflict with Runtime\Stubs
          $puredotsDupes = @(
            "Packages\\com.moni.puredots\\Runtime\\Runtime\\AI\\ConceptStubBehaviourTree.cs",
            "Packages\\com.moni.puredots\\Runtime\\Vehicles\\FighterSquadronStubComponents.cs"
          )
          foreach ($rel in $puredotsDupes) {
            $full = Join-Path $puredotsTarget $rel
            if (Test-Path $full) { Remove-Item -Force $full }
          }

          if ($clean) {
            $paths = @(
              "Library",
              "Library\\Bee",
              "Library\\ScriptAssemblies",
              "Temp",
              "Temp\\BeeArtifacts",
              "Temp\\UnityLockfile",
              "Library\\UnityLockfile"
            )
            foreach ($p in $paths) {
              $full = Join-Path $wt $p
              if (Test-Path $full) { Remove-Item -Recurse -Force $full }
            }
          }

          $queueRoot = '${{ inputs.queue_root }}'
          if ([string]::IsNullOrWhiteSpace($queueRoot)) {
            $queueRoot = "C:\\polish\\anviloop\\$title\\queue"
          }

          $args = @{
            Title = $title
            UnityExe = $env:UNITY_EXE
            ProjectPathOverride = $wt
            QueueRoot = $queueRoot
            Repeat = $repeat
          }
          if ($wait) { $args.WaitForResult = $true }
          if (-not [string]::IsNullOrWhiteSpace($scenarioRel)) { $args.ScenarioRel = $scenarioRel }

          $env:GIT_COMMIT = $ref
          $env:GIT_BRANCH = $ref

          $log = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke.log"
          & $pipeline @args 2>&1 | Tee-Object -FilePath $log
          # Determine success from pipeline_smoke summary to avoid leaked native exit codes.
          $summary = Join-Path $queueRoot "reports\\pipeline_smoke_summary_latest.md"
          $summaryCopy = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke_summary_latest.md"
          if (Test-Path $summary) {
            Copy-Item -Path $summary -Destination $summaryCopy -Force
            $summaryText = Get-Content $summaryCopy -Raw
            if ($summaryText -match '(?m)^\\* status: FAIL') {
              throw "pipeline_smoke reported FAIL (see $summaryCopy)"
            }
          } else {
            throw "pipeline_smoke summary missing: $summary"
          }
          # Clear any leaked native exit code so the workflow reflects the pipeline result.
          $global:LASTEXITCODE = 0

      - name: Collect diagnostics (always)
        if: ${{ always() }}
        continue-on-error: true
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Continue"

          $title = '${{ inputs.title }}'
          $queueRoot = '${{ inputs.queue_root }}'
          if ([string]::IsNullOrWhiteSpace($queueRoot)) {
            $queueRoot = "C:\\polish\\anviloop\\$title\\queue"
          }

          $diagRoot = Join-Path $env:GITHUB_WORKSPACE "buildbox_diag"
          if (Test-Path $diagRoot) { Remove-Item -Recurse -Force $diagRoot }
          New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null

          $pipelineLog = Join-Path $env:GITHUB_WORKSPACE "pipeline_smoke.log"
          if (Test-Path $pipelineLog) { Copy-Item $pipelineLog -Destination $diagRoot -Force }

          $summary = Join-Path $queueRoot "reports\\pipeline_smoke_summary_latest.md"
          if (Test-Path $summary) { Copy-Item $summary -Destination $diagRoot -Force }

          $buildId = $null
          $buildReportPath = $null
          $missingScriptsPath = $null
          $pptrScanPath = $null
          if (Test-Path $summary) {
            $summaryText = Get-Content $summary -Raw
            if ($summaryText -match '(?m)^\\* build_id:\\s*(\\S+)') { $buildId = $matches[1] }
            if ($summaryText -match '(?m)([A-Za-z]:\\\\[^\\r\\n]+HeadlessMissingScripts\\.log)') { $missingScriptsPath = $matches[1] }
            if ($summaryText -match '(?m)([A-Za-z]:\\\\[^\\r\\n]+PPtrCastScan\\.log)') { $pptrScanPath = $matches[1] }
            if ($summaryText -match '(?m)([A-Za-z]:\\\\[^\\r\\n]+\\.log)') { $buildReportPath = $matches[1] }
          }
          if ($buildReportPath -and (Test-Path $buildReportPath)) {
            $buildOutDir = Join-Path $diagRoot "build"
            if (-not (Test-Path $buildOutDir)) { New-Item -ItemType Directory -Path $buildOutDir -Force | Out-Null }
            $buildReportCopy = Join-Path $buildOutDir ([IO.Path]::GetFileName($buildReportPath))
            Copy-Item -Path $buildReportPath -Destination $buildReportCopy -Force
            Get-Content -Path $buildReportCopy -Tail 400 | Set-Content -Path ($buildReportCopy + ".tail.log")

            $buildDir = Split-Path $buildReportPath -Parent
            if (Test-Path $buildDir) {
              Get-ChildItem -Path $buildDir -Filter "*HeadlessBuildFailure*.log" -ErrorAction SilentlyContinue | ForEach-Object {
                $failureCopy = Join-Path $buildOutDir $_.Name
                Copy-Item -Path $_.FullName -Destination $failureCopy -Force
                Get-Content -Path $failureCopy -Tail 400 | Set-Content -Path ($failureCopy + ".tail.log")
              }
              Get-ChildItem -Path $buildDir -Filter "*HeadlessEditor.log" -ErrorAction SilentlyContinue | ForEach-Object {
                $editorCopy = Join-Path $buildOutDir $_.Name
                Copy-Item -Path $_.FullName -Destination $editorCopy -Force
                Get-Content -Path $editorCopy -Tail 800 | Set-Content -Path ($editorCopy + ".tail.log")
              }
            }
          }

          if ($missingScriptsPath -and (Test-Path $missingScriptsPath)) {
            $buildOutDir = Join-Path $diagRoot "build"
            if (-not (Test-Path $buildOutDir)) { New-Item -ItemType Directory -Path $buildOutDir -Force | Out-Null }
            $missingCopy = Join-Path $buildOutDir ([IO.Path]::GetFileName($missingScriptsPath))
            Copy-Item -Path $missingScriptsPath -Destination $missingCopy -Force
          }
          if ($pptrScanPath -and (Test-Path $pptrScanPath)) {
            $buildOutDir = Join-Path $diagRoot "build"
            if (-not (Test-Path $buildOutDir)) { New-Item -ItemType Directory -Path $buildOutDir -Force | Out-Null }
            $pptrCopy = Join-Path $buildOutDir ([IO.Path]::GetFileName($pptrScanPath))
            Copy-Item -Path $pptrScanPath -Destination $pptrCopy -Force
          }

          $zipPaths = New-Object System.Collections.Generic.List[string]
          if (Test-Path $pipelineLog) {
            $artifactLines = Select-String -Path $pipelineLog -Pattern 'artifact=([A-Za-z]:\\\\[^\\s]+\\.zip)' -AllMatches
            foreach ($line in $artifactLines) {
              foreach ($m in $line.Matches) {
                $zipPaths.Add($m.Groups[1].Value)
              }
            }
          }

          $resultsDir = Join-Path $queueRoot "results"
          if (Test-Path $resultsDir) {
            $z = Get-ChildItem -Path $resultsDir -Filter "result_*.zip" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 3
            foreach ($zip in $z) { $zipPaths.Add($zip.FullName) }
          }

          $artifactsDir = Join-Path $queueRoot "artifacts"
          if (Test-Path $artifactsDir) {
            $z = Get-ChildItem -Path $artifactsDir -Filter "artifact_*.zip" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 3
            foreach ($zip in $z) { $zipPaths.Add($zip.FullName) }
          }

          $zipPaths = $zipPaths | Where-Object { Test-Path $_ } | Sort-Object -Unique
          $zipFiles = @()
          foreach ($p in $zipPaths) {
            $fi = Get-Item -LiteralPath $p -ErrorAction SilentlyContinue
            if ($fi) { $zipFiles += $fi }
          }
          $zipFiles = $zipFiles | Sort-Object LastWriteTime -Descending
          Write-Host ("diag: found {0} zip(s)" -f $zipFiles.Count)

          $summaryPath = Join-Path $diagRoot "diag_summary.txt"
          $summaryLines = @()
          $summaryLines += "zip_count=$($zipFiles.Count)"

          $wanted = @(
            "meta.json",
            "out/watchdog.json",
            "out/run_summary.json",
            "out/invariants.json",
            "out/stdout.log",
            "out/stderr.log",
            "out/player.log",
            "out/unity.log",
            "out/diag_stdout_tail.txt",
            "out/diag_stderr_tail.txt",
            "logs/stdout.log",
            "logs/stderr.log",
            "logs/player.log",
            "logs/unity.log",
            "logs/primary_error_snippet.txt",
            "logs/unity_build_tail.txt",
            "build_outcome.json",
            "build/Space4X_HeadlessPPtrCastScan.log"
          )
          $wantedNames = @(
            "meta.json",
            "watchdog.json",
            "run_summary.json",
            "invariants.json",
            "out_watchdog.json",
            "out_run_summary.json",
            "out_invariants.json",
            "stdout.log",
            "stderr.log",
            "player.log",
            "unity.log",
            "diag_stdout_tail.txt",
            "diag_stderr_tail.txt"
          )
          $wantedRegex = "(?i)(^|/)crash/.*\\.log$"
          $extraLogRegex = "(?i)(^|/)(unity_full_.*\\.log|unity_build\\.log|unity_stdout_.*\\.log|unity_stderr_.*\\.log)$"
          $buildReportRegex = "(?i)(^|/)build/.*HeadlessBuildReport.*\\.log$"
          $buildFailureRegex = "(?i)(^|/)build/.*HeadlessBuildFailure.*\\.log$"
          $buildPPtrRegex = "(?i)(^|/)build/.*PPtrCastScan.*\\.log$"
          $logNameRegex = "(?i)(stdout|stderr|player|unity|unity_full_.*|unity_build|unity_stdout_.*|unity_stderr_.*)\\.log$"
          $logPathRegex = "(?i)(^|/)(stdout|stderr|player|unity|unity_full_.*|unity_build|unity_stdout_.*|unity_stderr_.*)\\.log$"
          $crashLogRegex = "(?i)(^|/)crash/.*\\.log$"
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zipSample = $zipFiles | Select-Object -First 2
          $zipIndex = 0
          foreach ($zipFile in $zipSample) {
            $zipIndex++
            $zipPath = $zipFile.FullName
            $zipName = [IO.Path]::GetFileNameWithoutExtension($zipPath)
            $dest = Join-Path $diagRoot ("results\\" + $zipName)
            New-Item -ItemType Directory -Path $dest -Force | Out-Null
            $archive = $null
            $jsonEntries = New-Object System.Collections.Generic.List[string]
            $matchEntries = New-Object System.Collections.Generic.List[string]
            try {
              $archive = [IO.Compression.ZipFile]::OpenRead($zipPath)
              foreach ($entry in $archive.Entries) {
                if ($entry.Name -match "(?i)\\.json$") { $jsonEntries.Add($entry.FullName) }
                $matchFull = $wanted -contains $entry.FullName
                $matchName = $wantedNames -contains $entry.Name
                $matchRegex = ($entry.FullName -match $wantedRegex) -or ($entry.Name -match $wantedRegex) -or ($entry.FullName -match $extraLogRegex) -or ($entry.Name -match $extraLogRegex) -or ($entry.FullName -match $buildReportRegex) -or ($entry.Name -match $buildReportRegex) -or ($entry.FullName -match $buildFailureRegex) -or ($entry.Name -match $buildFailureRegex) -or ($entry.FullName -match $buildPPtrRegex) -or ($entry.Name -match $buildPPtrRegex)
                if ($matchFull -or $matchName -or $matchRegex) {
                  $matchEntries.Add($entry.FullName)
                  $relative = if ($matchFull) { ($entry.FullName -replace '/', '\\') } else { ("flat\\" + $entry.Name) }
                  $outPath = Join-Path $dest $relative
                  $outDir = Split-Path $outPath -Parent
                  if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir -Force | Out-Null }
                  [System.IO.Compression.ZipFileExtensions]::ExtractToFile($entry, $outPath, $true)

                  $isLog = ($entry.Name -match $logNameRegex) -or ($entry.FullName -match $logPathRegex) -or ($entry.FullName -match $crashLogRegex)
                  if ($isLog -and (Test-Path $outPath)) {
                    $tailDir = Join-Path $dest "log_tails"
                    if (-not (Test-Path $tailDir)) { New-Item -ItemType Directory -Path $tailDir -Force | Out-Null }
                    $tailBase = ($entry.FullName -replace '[\\\\/:*?\"<>|]', '_')
                    $tailPath = Join-Path $tailDir ($tailBase + ".tail.log")
                    Get-Content -Path $outPath -Tail 400 -ErrorAction SilentlyContinue | Set-Content -Path $tailPath
                  }
                }
              }
            } finally {
              if ($archive) { $archive.Dispose() }
            }
            $summaryLines += ("zip[{0}]={1} json_count={2} match_count={3}" -f $zipIndex, $zipFile.Name, $jsonEntries.Count, $matchEntries.Count)
            foreach ($name in ($jsonEntries | Select-Object -First 10)) { $summaryLines += ("  json: " + $name) }
            foreach ($name in ($matchEntries | Select-Object -First 10)) { $summaryLines += ("  match: " + $name) }
          }

          $reportsDir = Join-Path $queueRoot "reports"
          if (Test-Path $reportsDir) {
            $reportsOut = Join-Path $diagRoot "reports"
            New-Item -ItemType Directory -Path $reportsOut -Force | Out-Null
            Get-ChildItem -Path $reportsDir -Filter "triage_*.json" -ErrorAction SilentlyContinue |
              Sort-Object LastWriteTime -Descending | Select-Object -First 5 |
              Copy-Item -Destination $reportsOut -Force
          }

          if ($buildId) {
            $stagingRoot = Join-Path $queueRoot "artifacts"
            if (Test-Path $stagingRoot) {
              $staging = Get-ChildItem -Path $stagingRoot -Directory -Filter ("staging_" + $buildId + "*") -ErrorAction SilentlyContinue |
                Sort-Object LastWriteTime -Descending | Select-Object -First 1
              if ($staging) {
                $stagingOut = Join-Path $diagRoot "staging"
                New-Item -ItemType Directory -Path $stagingOut -Force | Out-Null
                Get-ChildItem -Path $staging.FullName -Recurse -Filter "build_outcome.json" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "logs") -Filter "unity_build_tail.txt" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*HeadlessBuildReport*.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*HeadlessBuildFailure*.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*HeadlessMissingScripts.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                Get-ChildItem -Path (Join-Path $staging.FullName "build") -Filter "*PPtrCastScan*.log" -ErrorAction SilentlyContinue |
                  Copy-Item -Destination $stagingOut -Force
                $stagingLogs = Join-Path $staging.FullName "logs"
                $logPatterns = @("unity_full_*.log", "unity_stdout_*.log", "unity_stderr_*.log", "unity_build.log")
                foreach ($pattern in $logPatterns) {
                  Get-ChildItem -Path $stagingLogs -Filter $pattern -ErrorAction SilentlyContinue | ForEach-Object {
                    $dest = Join-Path $stagingOut $_.Name
                    Copy-Item -Path $_.FullName -Destination $dest -Force
                    Get-Content -Path $dest -Tail 400 -ErrorAction SilentlyContinue | Set-Content -Path ($dest + ".tail.log")
                  }
                }
              }
            }
          }

          $summarizer = Join-Path $env:TRI_ROOT "Tools\\HeadlessRebuildTool\\Polish\\Ops\\diag_summarize.ps1"
          if (Test-Path $summarizer) {
            $resultRoots = Get-ChildItem -Path (Join-Path $diagRoot "results") -Directory -ErrorAction SilentlyContinue
            foreach ($root in $resultRoots) {
              if (Test-Path (Join-Path $root.FullName "meta.json")) {
                try {
                  & $summarizer -ResultDir $root.FullName | Out-Null
                } catch {
                }
              }
            }
          }

          $summaryLines | Set-Content -Path $summaryPath

          $logsRoot = "C:\\polish\\anviloop\\logs"
          $logNames = @(
            "watchdog_heartbeat.log",
            "watch_daemon_${title}.log",
            "wsl_runner_${title}.log",
            "intel_${title}.log"
          )
          foreach ($ln in $logNames) {
            $path = Join-Path $logsRoot $ln
            if (Test-Path $path) {
              $dest = Join-Path $diagRoot ("logs\\" + $ln)
              $destDir = Split-Path $dest -Parent
              if (-not (Test-Path $destDir)) { New-Item -ItemType Directory -Path $destDir -Force | Out-Null }
              Get-Content -Path $path -Tail 500 | Set-Content -Path $dest
            }
          }

          # Extract compiler errors into a single easy-to-scan file.
          $compileOut = Join-Path $diagRoot "compiler_errors.txt"
          $compileLines = @()
          $compileLines += "compiler_error_scan_root=$diagRoot"
          $compileLines += "pattern=error CS#### (case-insensitive)"
          $candidateLogs = Get-ChildItem -Path $diagRoot -Recurse -File -Include *.log,*.txt -ErrorAction SilentlyContinue
          foreach ($log in $candidateLogs) {
            try {
              $hits = Select-String -Path $log.FullName -Pattern 'error\\s+CS\\d{4,5}' -AllMatches -Context 2,2 -ErrorAction SilentlyContinue
              if ($hits) {
                $compileLines += "file=" + $log.FullName
                foreach ($hit in $hits) { $compileLines += $hit.ToString() }
              }
            } catch {
            }
          }
          if ($compileLines.Count -gt 2) {
            $compileLines | Set-Content -Path $compileOut
          } else {
            "no compiler errors found" | Set-Content -Path $compileOut
          }

          # Extract first meaningful build error signature for quick triage.
          $errorSummary = Join-Path $diagRoot "build_error_summary.txt"
          $sigPatterns = @(
            "PPtr cast failed",
            "Missing (Mono)?Script",
            "error\s+CS\d{4,5}",
            "Bee\.\w+Exception",
            "ScriptCompilation",
            "Build failed",
            "ExecuteMethod",
            "UnityException"
          )
          $firstHit = $null
          foreach ($pattern in $sigPatterns) {
            foreach ($log in $candidateLogs) {
              try {
                $hit = Select-String -Path $log.FullName -Pattern $pattern -Context 3,6 -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($hit) {
                  $firstHit = @(
                    "pattern=$pattern",
                    "file=$($log.FullName)",
                    $hit.ToString()
                  )
                  break
                }
              } catch {
              }
            }
            if ($firstHit) { break }
          }
          if ($firstHit) {
            $firstHit | Set-Content -Path $errorSummary
          } else {
            "no build error signature found" | Set-Content -Path $errorSummary
          }

          # Missing script triage: extract asset paths from logs.
          $missingScriptsOut = Join-Path $diagRoot "missing_scripts.txt"
          $missingLines = @()
          foreach ($log in $candidateLogs) {
            try {
              $hits = Select-String -Path $log.FullName -Pattern "Missing script asset:" -AllMatches -ErrorAction SilentlyContinue
              if ($hits) {
                foreach ($hit in $hits) {
                  $missingLines += $hit.ToString()
                }
              }
            } catch {
            }
          }
          if ($missingLines.Count -gt 0) {
            $missingLines | Set-Content -Path $missingScriptsOut
          } else {
            "no missing script assets found in logs" | Set-Content -Path $missingScriptsOut
          }

      - name: Upload pipeline log
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: pipeline_log
          path: pipeline_smoke.log

      - name: Upload diagnostics
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: buildbox_diag_${{ inputs.title }}_${{ github.run_id }}
          path: buildbox_diag
          retention-days: 14

# noop touch for workflow_dispatch registration
